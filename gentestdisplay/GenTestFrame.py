# -*- coding: UTF-8 -*-
#
# generated by wxGlade 1.0.1 on Fri Mar 19 10:57:37 2021
#

import wx
# begin wxGlade: dependencies
# end wxGlade

# begin wxGlade: extracode
# end wxGlade


import traceback
try:
    from queue import Queue
except:
    from Queue import Queue


from PlotGraph import *
import time
import math
import numpy as np
import json
from vartab import *
import math

CONFIGFILE = ".gentestdisplpay"

class GenTestFrame(wx.Frame):
    __DEFAULT_SCAN_RATE = 600    # Points per seconds on all points

    def __init__(self, *args, **kwds):
        # begin wxGlade: GenTestFrame.__init__
        kwds["style"] = kwds.get("style", 0) | wx.DEFAULT_FRAME_STYLE
        wx.Frame.__init__(self, *args, **kwds)
        self.SetTitle(_("Generator Test"))
        self.SetMinSize((800, 600))

        self.mainPanel = wx.Panel(self, wx.ID_ANY)
        self.mainPanel.SetMinSize((1024, 800))

        self.mainSizer = wx.FlexGridSizer(1, 1, 4, 5)

        self.graphSizer = wx.FlexGridSizer(0, 1, 0, 0)
        self.mainSizer.Add(self.graphSizer, 1, wx.ALL | wx.EXPAND, 0)

        self.graphSizer.AddGrowableCol(0)

        self.mainSizer.AddGrowableRow(0)
        self.mainSizer.AddGrowableCol(0)
        self.mainPanel.SetSizer(self.mainSizer)

        self.mainSizer.Fit(self)
        self.Layout()

        self.Bind(wx.EVT_CLOSE, self.OnClose, self)
        # end wxGlade

        self.__labjack_port = None
        self.__labjack = None
        self.__graphitems = {}
        self.__packet_thread_id = None
        self.__queue = Queue()
        self.__log_file = None
        self.__playback_file = None
        self.__playback_thread = None

        self.__config = VarTab()

        # Try to load from config file and not not successful, preset the configuration
        try:
            with open(os.path.join(os.getenv("HOME"), CONFIGFILE)) as f:
                self.__config.Load(json.reads(f.read()))

        except:
            # Failed to load - reset config and load initial values
            self.__config.Reset()

            self.__config.SetValue('global.scanrate', self.__DEFAULT_SCAN_RATE)

            # Define the configured channels
            self.__config.SetValue('channels.p1volts', {})
            self.__config.SetValue('channels.p2volts', {})
            self.__config.SetValue('channels.p1amps', {})
            self.__config.SetValue('channels.p2amps', {})

            # Define the settings for the FFT display
            self.__config.SetValue('graphs.fft.channels', [ "p1volts", "p2volts" ])
            self.__config.SetValue('graphs.fft.params.plottype', 'fft')
            self.__config.SetValue('graphs.fft.params.points', "$eval{int(${global.scanrate} / 2)}")
            self.__config.SetValue('graphs.fft.params.xmin', 0)
            self.__config.SetValue('graphs.fft.params.xmax', "$eval{int(${global.scanrate})}")
            self.__config.SetValue('graphs.fft.params.ymin', -20)
            self.__config.SetValue('graphs.fft.params.ymax', 80)
            self.__config.SetValue('graphs.fft.params.yconvert', "$eval{lambda y: 10*math.log10(y) if y != 0 else 0}")
            self.__config.SetValue("graphs.fft.params.results", "thd")

            # Define the settings for the Frequency graph
            self.__config.SetValue('graphs.freq.channels', [ "p1volts", "p2volts" ])
            self.__config.SetValue('graphs.freq.params.plottype', 'ts')
            self.__config.SetValue('graphs.freq.params.points', 300)
            self.__config.SetValue('graphs.freq.params.xmin', 0)
            self.__config.SetValue('graphs.freq.params.xmax', 300)
            self.__config.SetValue('graphs.freq.params.ymin', -20)
            self.__config.SetValue('graphs.freq.params.ymax', 20)
            self.__config.SetValue('graphs.freq.params.xlabelfun', "$eval{lambda x: '%.2f' % (x / ${global.scanrate})}")

            # Define the settings for the Current graph
            self.__config.SetValue('graphs.current.channels', [ "p1amps", "p2amps" ])
            self.__config.SetValue('graphs.current.params.plottype', 'ts')
            self.__config.SetValue('graphs.current.params.xmin', 0)
            self.__config.SetValue('graphs.current.params.xmax', 300)
            self.__config.SetValue('graphs.current.params.ymin', -20)
            self.__config.SetValue('graphs.current.params.ymax', 20)

            try:
                with open(os.path.join(os.getenv("HOME"), CONFIGFILE), "w") as f:
                   f.write(json.dumps(self.__config.GetValue(), indent=4, sort_keys=True))
            except Exception as e:
                traceback.print_exc()

        self.ReloadGraphs()


    def ReloadGraphs(self):
        # Remove all children
        for child in self.graphSizer.GetChildren():
            window = child.GetWindow()
            if window is not None:
                print("Removing: %s" % window)
                self.graphSizer.Detach(window)

        self.__graphitems = {}

        try:
            graphs = self.__config.GetValue("graphs")
            row = 0
            for name in graphs:
                graph_info = graphs[name]
                params = self.__config.GetValue("params", base=graph_info)
                graph_params = {}
                for param in params:
                    graph_params[param] = self.__config.GetValue(param, base=params)

                print("Graph %s params %s" % (name, graph_params))
                graph = PlotGraph(parent=self.mainPanel, name="Graph %s" % name, style=0)
                self.graphSizer.AddGrowableRow(row)
                self.graphSizer.Add(graph, proportion=1, border=0, flag=wx.EXPAND)
                graph.SetParams(graph_params)
                self.__graphitems[name] = graph
#                graph.SetChannelColors()
                # graph.SetSizer(self.graphSizer)
                row = row + 1

        except Exception as e:
            traceback.print_exc()

        self.graphSizer.Layout()
        # self.Update()
        self.Refresh()

    def StartCapture(self):
        selected = self.portCombo.GetValue()

        if selected is not None:
            sn, connection = selected.split(':')

            self.__labjack = GetLabJackHandler().Open(sn, connection=connection)
            self.__data = {}

            # Start the collector
            rc = self.__labjack.StreamStart(channels=self.__CHANNELS, scan_rate=self.__SCAN_RATE, scans_per_read=int(self.__SCAN_RATE/self.__NUM_CHANNELS), callback=self.__capture_data)
            # print("StreamStart returned %d" % rc)

            if rc != 0:
                self.__packet_thread_id = Thread(target=self.__packet_thread)
                self.__packet_thread_id.start()
            else:
                wx.MessageBox(u"Unable to start packet thread", u"Packet Thread")

    def __capture_data(self, handle, data):
        self.__queue.put(data)

    def __update_fft_with_thd(self, value, channel_name):
        # print("__update_thd_with_thd: channel_name %s value %s" % (channel_name, value))
        results = self.__graphitems[0].SetValue(value, channel=channel_name)
        # print("__update_fft_with_thd returned results %s" % results)
        if "thd" in results:
            if channel_name == "AIN0":
                self.frequencyTHDtext1.SetValue("%.1f" % results["thd"])
            else:
                self.frequencyTHDtext2.SetValue("%.1f" % results["thd"])


    # This receives the data packets from the LabJack Streams
    def __packet_thread(self):
        running = True
        while running:
            packet = self.__queue.get()
            # print("__packet_thread: %s" % str(packet))
            if packet is None:
                # All done - shut down
                running = False

            else:
                # print(".", end='', flush=True)

                data = packet[0]

                data0 = [ data[n] for n in range(0, len(data), 2) ]
                data1 = [ data[n] for n in range(1, len(data), 2) ]

                # Send the two channels to the plots
                if self.enableFFTCheckbox1.IsChecked():
                    wx.CallAfter(self.__update_fft_with_thd, value=data0, channel_name="AIN0")

                if self.enableFFTCheckbox2.IsChecked():
                    wx.CallAfter(self.__update_fft_with_thd, value=data1, channel_name="AIN1")

                if self.enableGraphCheckbox1.IsChecked():
                    wx.CallAfter(self.__graphitems[1].SetValue, data0, channel="AIN0")

                if self.enableGraphCheckbox2.IsChecked():
                    wx.CallAfter(self.__graphitems[1].SetValue, data1, channel="AIN1")

                # Send data to log file if requested
                if self.__log_file is not None:
                    for index in range(0, len(data), 2):
                        self.__log_file.write("%.4f,%.4f\n" % (data[index], data[index+1]))

    def StopCapture(self):
        if self.__labjack is not None and self.__packet_thread_id is not None:
            self.__labjack.StreamStop()
            self.__packet_thread_id.join()
            self.__packet_thread_id = None

###    def OnExitButton(self, event):  # wxGlade: GenTestFrame.<event_handler>
###        self.CloseLogger()
###        wx.Exit()
###        event.Skip()

    def CloseLogger(self):
        # print("CloseLogger...")
        self.StopCapture()

        for graph in self.__graphitems:
            self.__graphitems[graph].Stop()

        if self.__labjack != None:
            self.__labjack.Close()
            self.__labjack = None

    def OnClose(self, event):  # wxGlade: GenTestFrame.<event_handler>
        self.CloseLogger()
        event.Skip()

    def StartLog(self):  # wxGlade: GenTestFrame.<event_handler>
        if self.__log_file is not None:
            with wx.MessageDialog(self, u"Already Logging.  Replace current log file?", caption=u"Close Current Log File", style=wx.CENTER | wx.YES | wx.CANCEL) as question:
                if question.showModal() == wx.ID_YES:
                    self.__log_file.close()
                    self.__log_file = None

        if self.__log_file == None:
            with wx.FileDialog(self, "Create log file", wildcard="LOG files (*.log)|*.log",
                           style=wx.FD_SAVE | wx.FD_OVERWRITE_PROMPT) as fileDialog:

                if fileDialog.ShowModal() != wx.ID_CANCEL:
                    # save the current contents in the file
                    pathname = fileDialog.GetPath()
                    try:
                        self.__log_file = open(pathname, "w+")
                        # Put date/time in comment
                        self.__log_file.write(u",,Info:SPS=%d CHANNELS=%d; Started:%s\n" % (self.__SCAN_RATE, 2, str(wx.DateTime.Now())))
                        self.loggingStatus.Show()
                        self.configSizer.Layout()

                    except IOError:
                        wx.LogError("Cannot log to file '%s'." % pathname)

        event.Skip()

    def __playback_data(self, samples_per_second):
        time_between_samples = 1.0/float(samples_per_second)

        running = True

        while running:
            data = []

            working = True

            while working and len(data) < 100:
                try:
                    chunk = self.__playback_file.readline().strip()
                    if len(chunk) == 0:
                        print("final was %d items" % len(chunk))
                        working = False
                    else:
                        data.extend(chunk.split(','))
                except:
                    working = False
                
            # print("data is %s" % data)

            if len(data) != 0:
                data = [[float(value) for value in data]]

                # print("__playback_data: %s" % data)

                # Write as list of floats
                self.__queue.put(data)

                # print("Sleeping %f seconds" % time_between_samples)

                time.sleep(time_between_samples * len(data[0]))
                # print("tick %d"  % len(data[0]))

            else:
                wx.CallAfter(self.StopPlayback)
                running = False

    def StartPlayback(self, pathname):
        try:
            file = open(pathname, "r")
            # Read first line to get info
            info = file.readline()
            starting = info.find("Info:")
            ending = info.find(";")

            if starting >= 0 and ending >= 0:
                items = info[starting+5:ending].strip().split(' ')
                samples_per_second = 0

                for item in items:
                    name, value = item.split('=')
                    if name == "SPS":
                        samples_per_second = int(value)

                if samples_per_second != 0:
                    # Start thread to process data
                    self.__packet_thread_id = Thread(target=self.__packet_thread)
                    self.__packet_thread_id.start()

                    # Set current playback file
                    self.__playback_file = file

                    # Start thread to read data and put in queue
                    self.__playback_thread = Thread(target=self.__playback_data, args=(samples_per_second,))
                    self.__playback_thread.start()

            self.playbackButton.SetLabel(u"Stop Playback")
            self.configSizer.Layout()

        except:
            wx.MessageBox(u"Unable to playback %s" % pathname, u"File Error")


    def StopPlayback(self):
        print("StopPlayback called")
        try:
            self.__playback_file.close()
            self.__playback_thread.join()

        except:
            pass

        self.playbackButton.SetLabel(u"Playback")
        self.configSizer.Layout()

        self.__playback_file = None

    def StopLog(self):  # wxGlade: GenTestFrame.<event_handler>
        if self.__log_file is not None:
            self.__log_file.close()
            self.__log_file = None
            self.loggingStatus.Hide()
            self.configSizer.Layout()

    def StartPlayback(self):  # wxGlade: GenTestFrame.<event_handler>
        if self.__playback_file is not None:
            self.StopPlayback()
        else:
            with wx.FileDialog(self, "Playback log file", wildcard="LOG files (*.log)|*.log", style=wx.FD_OPEN) as fileDialog:
                if fileDialog.ShowModal() == wx.ID_OK: 
                    self.StartPlayback(fileDialog.GetPath())

# end of class GenTestDisplay
